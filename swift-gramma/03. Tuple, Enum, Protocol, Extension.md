### ğŸ swift-grammar, Today I Learn 
<1> Tuple  
<2> Enum  
<3> Protocol  
<4> Extension  
#

### <b> <1> Tuple</b>
#### 1. íŠœí”Œì´ë€? ì–´ë–¤ ê°’ë“¤ì˜ ë¬¶ìŒ
#### 2. íŠœí”Œì˜ íŠ¹ì§•
1. ë°°ì—´ê³¼ ë¹„ìŠ·í•¨
2. ë°°ì—´ê³¼ ë‹¤ë¥´ê²Œ ê¸¸ì´ê°€ ê³ ì •ë˜ì–´ìˆìŒ
3. ê°’ì— ì ‘ê·¼í•  ë•Œ `.`ì„ ì‚¬ìš©í•¨

```swift
var coffee = ("americano", 100)
coffee.0 //americano
coffee.1 // 100
coffee.1 = 100

//íŒŒë¼ë¯¸í„°ì— ì´ë¦„ë¶™ì´ê¸°
var juice = (fruit: "orange", price: 200)
juice.fruit // orange
juice.price // 200
```

#### 3. íŠœí”Œ íƒ€ì…ì˜ ì–´ë…¸í…Œì´ì…˜ì€ ì–´ë–»ê²Œ ìƒê²¼ì„ê¹Œ?  
`var coffee: (String, Int)`  
`var juice: (fruit: String, price: Int)`  

#### 4. íŠœí”Œ ì‘ìš©í•˜ê¸°
1. ì—¬ëŸ¬ ë³€ìˆ˜ì˜ ê°’ ì§€ì •í•˜ê¸°
```swift
let (coffee, price) = ("americano, 100)
coffee // americano
price // 5100
```

2. íŠœí”Œì´ ê°€ì§„ ê°’ìœ¼ë¡œ ë³€ìˆ˜ê°’ ì§€ì •ì‹œ ë¬´ì‹œí•˜ê³  ì‹¶ìœ¼ë©´ `_` í‚¤ì›Œë“œ ì‚¬ìš©
```swift
let(_, size, price) = ("latte", "venti", 300)
size // venti
price // 300
```
  
3. íŠœí”Œì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ ë§Œë“¤ê¸°
```swift
func menu(for name: String) => (name: String, price: Int) {
  let menuList : [(name: String, price: Int)] = [
    ("americano", 100), ("latte", 200),
  ]
    
  for menu in menuList {
    if menu.name == name{ return menu } //ì´ë¦„ì´ ì¼ì¹˜í•˜ë©´ ì»¤í”¼ ì´ë¦„, ê°€ê²© ì •ë³´ë¡œ êµ¬ì„±ëœ íŠœí”Œ ë°˜í™˜
  }
    return nil //ì¼ì¹˜í•˜ëŠ” ì •ë³´ ì—†ìœ¼ë©´ nilë°˜í™˜ }

menu(for "americano")?.price // 100
menu(for "espresso")?.price // nil

let(_, lattePrice) = menu(for: "latte")!
lattePrice // 200
```

#
### <b> <2> Enum</b>
#### 1. enum ì •ì˜í•˜ê¸°
1. `enum`, `case` í‚¤ì›Œë“œ ì‚¬ìš©
```swift
enum Month : Int { //ì—´ê±°ëœ ê° ê°’ë“¤ì€ Intí˜•ì„
  case jan = 1 ///ì´ì œ ê° ì¼€ì´ìŠ¤ë“¤ì€ 1~6ê¹Œì§€ì˜ ê°’ì„ ê°€ì§
  case feb
  case mar
  case apr
  case may
  case jun
  
  
  func simpleDescription() -> String{
    switch self{
      case .jan:
        return "1ì›”"
      case .feb:
        return "2ì›”"
      case .mar:
        return "3ì›”"
      case .apr:
        return "4ì›”"
      case .may:
        return "5ì›”"
      case .jun:
        return "6ì›”"
    }
  }
}
  
  let may = Month.may
  print(may.simpleDescription()) // 5ì›”
  print(may.rawValue) // 5
```

```swift
let mar = Month(rawValue: 3)
print(mar) // optional(month.mar)
//Month(rawValue: 3)ì˜ ë°˜í™˜ê°’ì´ optionalì¸ ì´ìœ : enumì—ì„œ ì •ì˜ë˜ì§€ ì•ŠëŠ” ì›ì‹œê°’ì„ ê°€ì§€ê³  ìƒì„±í•  ê²½ìš° nilë°˜í™˜í•˜ë¯€ë¡œ
let oct = Month(rawValue: 10) // nil
```

#### 2. íŠ¹ì§•
1. ì¼ë°˜ì : Intë§Œ ì›ì‹œê°’ìœ¼ë¡œ ê°€ì§
2. swift
- Intì™¸ì˜ íƒ€ì…ë„ ì›ì‹œê°’ìœ¼ë¡œ ê°€ì§ˆ ìˆ˜ ìˆìŒ

```swift
  enum IssueState: String{
    case open = "open"
    case closed = "closed"
  } //ì •ìƒ
```

- ì›ì‹œê°’ì„ ê°€ì§€ì§€ ì•Šì„ ìˆ˜ ìˆìŒ
```swift
enum Spoon: String{
  case silver
  case gold

  func simpleDescription() -> String{
    switch self{
      case .silver:
        return "ì€ìˆ˜ì €"
      case . gold:
        return "ê¸ˆìˆ˜ì €"
    }
  }
} //ì •ìƒ
```

- enum ì˜ˆì¸¡í•  ìˆ˜ ìˆë‹¤ë©´, enumì˜ ì´ë¦„ ìƒëµ ê°€ëŠ¥ (ì½”ë“œ ê°„ê²°í•´ì§€ëŠ” ì¥ì æœ‰)
```swift
let spoon: Spoon = .gold
func doSomething(with spoon: Spoon){ //í•¨ìˆ˜ ì •ì˜
    //...
  }

  doSomething(with: .silver) //í•¨ìˆ˜ ì •ì˜ì— íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì´ ìˆìœ¼ë¯€ë¡œ ìƒëµí•  ìˆ˜ ìˆìŒ
```

#### 3. ì—°ê´€ê°’ì„ ê°€ì§€ëŠ” Enum
1. ì—°ê´€ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆë‹¤.
```swift
//ì–´ë–¤ APIì— ëŒ€í•œ ì—ëŸ¬ë¥¼ ì •ì˜í•¨, invalidParameterì¼€ì´ìŠ¤ëŠ” í•„ë“œì˜ ì´ë¦„ê³¼ ë©”ì„¸ì§€ë¥¼ ê°€ì§€ë„ë¡ ì •ì˜ë¨

enum NetworkError{
  case invalidParameter(String, String)
  case timeout
}

let error: NetworkError = .invalidParameter("email", "ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.")
 
  
//ìœ„ì˜ ê°’ì„ êº¼ë‚´ì˜¤ëŠ” ë°©ë²•: if-case, switch
//ë°©ë²•1
if case .invalidParameter(let field, let message) = error {
  print(field) // email
  print(message) //ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.
}
  
//ë°©ë²•2
switch error{
case .invalidParameter(let field, let message):
  print(field) // email
  print(message) //ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.
}
```

### 4. ì‚¬ì‹¤, ì˜µì…”ë„ì€ Enumì´ë‹¤.
1. ì˜µì…”ë„ì˜ í˜•íƒœ
```swift
public enum Optional<Wrapped>{
  case none
  case some(Wrapped)
}
```

```swift
let age: Int? = 20

switch age{
case .none // nilì¸ ê²½ìš°
  print("ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤."

case .some(let x) where x < 20:
  print("ì²­ì†Œë…„")

case .some(let x) where x < 65:
  print("ì„±ì¸")
  
default:
  print("ì–´ë¥´ì‹ ")
} //ê°€ëŠ¥
```

#
### <b> <3> Protocol</b>
#### 1. í”„ë¡œí† ì½œ: `protocol`
1. í”„ë¡œí† ì½œ == ì¸í„°í˜ì´ìŠ¤
- ìµœì†Œí•œìœ¼ë¡œ ê°€ì§ˆ ì†ì„±, ë©”ì„œë“œ ì •ì˜
- êµ¬í˜„í•˜ì§€ ì•Šê³  ì •ì˜ë§Œí•¨ (ë¹ˆê»ë°ê¸°)
```swift
protocol sendable{
  var from: String? { get }
  var to: String { get } 
  
  func send()
}
```

2. `class` `struct`ì— í”„ë¡œí† ì½œì„ ì ìš© ì‹œí‚¬ ìˆ˜ ìˆìŒ
- ë‹¨, ì ìš©ì‹œ í”„ë¡œí† ì½œì—ì„œ ì •ì˜í•œ ì†ì„±, ë©”ì„œë“œë¥¼ ëª¨ë‘ êµ¬í˜„í•´ì•¼ í•¨
```swift
struct Mail: Sendable{ //3.-2)
  var from: String?
  var to: String
  
  //ì ìš©í•  ë•Œ ë©”ì„œë“œ êµ¬í˜„
  func send(){
    print("Send a mail from \(self.from) to \(self.to)")
  }
}
  
struct Feedback: Sendable{ //3.-2)
  var from: String? {
    return nil //fromë³€ìˆ˜ì˜ ë¦¬í„´ê°’ì€ ìµëª…ì²˜ë¦¬í•˜ê¸° ìœ„í•´
  }
  var to String
  
  func send(){
    print("Send a feedback to \(self.to)")
  }
}
```

3. í”„ë¡œí† ì½œì€ ì¶”ìƒí´ë˜ìŠ¤ì²˜ëŸ¼ ì‚¬ìš©ë  ìˆ˜ ìˆìŒ
- 1) sendAnything() í•¨ìˆ˜ëŠ” Sendableíƒ€ì…ì„ íŒŒë¼ë¯¸í„°ë¡œ ë°›ëŠ”ë‹¤.
- 2) Mailê³¼ Feedbackì€ ì—„ì—°íˆ ë‹¤ë¥¸ íƒ€ì…ì´ì§€ë§Œ ëª¨ë‘ Sendableì„ ë”°ë¥´ê³  ìˆìŒ
- 3) Sendableì—ì„œëŠ” send()í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ê³  ìˆìœ¼ë¯€ë¡œ í˜¸ì¶œí•  ìˆ˜ê°€ ìˆë‹¤.
```swift
func sendAnything(_ sendable: Sendable){ //3.-1)
  sendable.send() //3.-3)
}
  
let mail = Mail(from: "dev@gmail.com", to: "style@style.re")
senAnything(mail) // Send a mail from dev@gmail.com to style@style.re 

let feedback = Feedback(from: "dev@gmail.com")
sendAnything(feedback) // Send a feedback to dev@gmail.com
```

4. í”„ë¡œí† ì½œì€ ë˜ ë‹¤ë¥¸ í”„ë¡œí† ì½œì„ ë”°ë¦„
- Sendableì€ Messageable í•¨ìˆ˜ë¥¼ ë”°ë¥´ëŠ” í”„ë¡œí† ì½œì´ë‹¤.
- Sendableì„ ì ìš©í•˜ë ¤ë©´ `var message: String? { get }`ì„ ì •ì˜í•´ì£¼ì–´ì•¼ í•œë‹¤.
```swift
protocol Messageable{
  var message: String? { get }
}

protocol Sendable: Massageable{
  // ..
}
}
```

#### 2. Anyì™€ AnyObject
1. Any: ëª¨ë“  íƒ€ì…ì— ëŒ€ì‘í•¨.
   AnyObject: ëª¨ë“  ê°ì²´ì— ëŒ€ì‘í•¨
```swift
  let anyNumber: Any = 10 //OK
  let anyString: Any = "Hi" //OK
  
  let anyInstance: AnyObject = Dog() //OK
```
  
#### 3. Type Casting  
1. anyëŠ” í”„ë¡œí† ì½œì„ ë”°ë¥´ëŠ” ì–´ë–¤ ê°’ì´ë‹¤.
- `anyNumber`ì— `10`ì„ ë„£ì—ˆë‹¤ê³  í•´ì„œ `Int type`ì¸ ê²ƒì€ ì•„ë‹ˆë‹¤.
```swift
anyNumber + 1// ì»´íŒŒì¼ ì—ëŸ¬
```
- ì™œ ì»´íŒŒì¼ì—ëŸ¬ê°€ ë‚ ê¹Œ? `anyNumber`ëŠ” `Int type`ì´ ì•„ë‹Œ í”„ë¡œí† ì½œì„ ë”°ë¥´ëŠ” ì–´ë–¤ ê°’ì´ë¯€ë¡œ

2. í•´ê²°ë°©ë²•: `as?` ì˜µì…”ë„ì„ ì·¨í•´ ë‹¤ìš´ ìºìŠ¤íŒ…í•œë‹¤.
```swift
let number: Int? = anyNumber as? Int //OK
```

3. ì˜µì…”ë„ ë°”ì¸ë”© ë¬¸ë²• ì‚¬ìš©ë„  OK (ì‹¤ì œë¡œ ë§ì´ ì‚¬ìš©ë˜ëŠ” ë°©ë²•)
```swift
if let number = anyNumber as? Int {
  print(number + 1)  
}
```

  
#### 4. íƒ€ì… ê²€ì‚¬ `is`
1. ì–´ë–¤ ê°’ì´ íŠ¹ì •í•œ íƒ€ì…ì¸ì§€ ê²€ì‚¬í•˜ê³  ì‹¶ì„ ë•Œ `is`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
```swift
print(anyNumber is Int) //true
print(anyNumber is Any) //true
print(anyNumber is String) //false
print(anyString is String) //true
```
 
#### 5. Swiftì˜ ì£¼ìš” í”„ë¡œí† ì½œ - `CustomerStringConvertible`
1. CustomerStringConvertible
- ìê¸° ìì‹ ì„ í‘œí˜„í•˜ëŠ” ë¬¸ìì—´ ì •ì˜ `print()` `String()` `\()`ì—ì„œ ì‚¬ìš©ë  ë•Œì˜ ê°’
2. ìƒê¹€ìƒˆ
```swift
public protocol CustomStringConvertible {
  /// A textual representation of `self`.
  public var description: String { get }
}
```
3.ì‹¤ì œ ì ìš©
```swift
struct Dog: CustomStringConvertible{
  var name: String
  var description: String{ return "(\self.name)" }
} // Dogë¼ëŠ” êµ¬ì¡°ì²´ëŠ” nameì´ë¼ëŠ” ë³€ìˆ˜ì™€ descriptionì´ë¼ëŠ” ë³€ìˆ˜ë¥¼ ë‹´ê³  ìˆë‹¤.
  // descriptionì´ë¼ëŠ” ë³€ìˆ˜ì—ì„œ nameì„ ë°˜í™˜í•œë‹¤.
  
  let dog = Dog(name: "ì•ˆë…•")
  print(dog) //ì•ˆë…•
```
  
#### 6. Swiftì˜ ì£¼ìš” í”„ë¡œí† ì½œ - `ExpressibleBy`
1. ë¦¬í„°ëŸ´
- ì¦‰, `10`ì€ `Int`, `hi`ëŠ” `String`ì´ë¼ê³  ì¸ì§€í•˜ê³  ìˆì—ˆì§€ë§Œ, ì—„ë°€íˆ ë”°ì§€ë©´ `10`ì€ `Int(10)`, `hi`ëŠ” `String(hi)`ë¡œ ì„ ì–¸ë˜ì–´ì•¼ í•œë‹¤. 
- ì™œëƒí•˜ë©´, Int, Stringì€ ëª¨ë‘ `ìƒì„±ìë¥¼ ê°€ì§€ëŠ” êµ¬ì¡°ì²´` ì´ê¸° ë•Œë¬¸ì´ë‹¤.
- ì´ì²˜ëŸ¼, ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³ ë„ ìƒì„±í•  ìˆ˜ ìˆê²Œ ë§Œë“œëŠ” ê²ƒì„ `ë¦¬í„°ëŸ´`ì´ë¼ê³  í•œë‹¤.  
```swift
let number = 10 //ë¬¸ì ê·¸ëŒ€ë¡œ 10
let string = "hi"//ë¬¸ì ê·¸ëŒ€ë¡œ hi
let array = ["a", "b", "c"] //ë¬¸ì ê·¸ëŒ€ë¡œ ë°°ì—´
let dictionary = [ //ë¬¸ì ê·¸ëŒ€ë¡œ ë”•ì…”ë„ˆë¦¬
  "id": "value1",
  "pw": "value2",
] 
```

2. ë¦¬í„°ëŸ´ì„ ê°€ëŠ¥í•˜ê²Œ í•´ì£¼ëŠ” í”„ë¡œí† ì½œ - `ExpressibleByXXXLiteral`
- ê° í”„ë¡œí† ì½œì€ ë¦¬í„°ëŸ´ ê°’ì„ ë°›ëŠ” ìƒì„±ìë¥¼ ì •ì˜í•˜ê³  ìˆë‹¤.
  - Int => `ExpressibleByIntegerLiteral`
  - String => `ExpressibleByStringLiteral`
  - Array => `ExpressibleByArrayLiteral`
  - Dictionary => `ExpressibleByDictionaryLiteral`
3. ë§Œë“¤ì–´ë³´ê¸°
```swift
struct DollarConverter: ExpressibleByIntegerLiteral{ // DollarConverter êµ¬ì¡°ì²´ ì •ì˜
  typealias IntegerLiteralType = Int
  
  let price = 1_307 // 2022.08.02í™˜ìœ¨ ê¸°ì¤€. ê°€ë…ì„±ì„ ìœ„í•´ 1307ì„ 1_307ë¡œ ì‚¬ìš©
  var dollers: Int
  
  init(integerLiteral value: IntegerLiteralType){
    self.dollars = value * self.price  
  }
}

let converter: DollarConverter = 100
converter.dollars // initë¶€ë¶„ ì ìš©ë˜ë¯€ë¡œ, ê²°ê³¼ê°’ì€ 137000
```
- TIP
```markdown
typealiasë€, ê¸°ì¡´ì— ì„ ì–¸ëœ ìœ í˜•ì— ìƒˆë¡œìš´ ìœ í˜•ì˜ ë³„ì¹­ì„ ì‚¬ìš©í•˜ì—¬ ì½”ë“œë¥¼ ë” ê°€ë…ì„± ì¢‹ê²Œ ëª…í™•íˆ ë§Œë“œëŠ” ë¬¸ë²•(Cì˜ typedef)
typealias MyInt = Intë¼ê³  í•˜ë©´, MyIntëŠ” Intì™€ ì™„ì „íˆ ë™ì¼í•œ íƒ€ì…
protocolì—ì„œ typealias ì •ì˜ ê°€ëŠ¥
swiftëŠ” typealiasë¥¼ ëŒ€ë¶€ë¶„ 3ê°€ì§€ ìœ í˜•ìœ¼ë¡œ ë‚˜ëˆˆë‹¤.
  - ë‚´ì¥ ìœ í˜•: String, Int, Float ...
  - ì‚¬ìš©ìì •ì˜ ìœ í˜•: Class, Struct, Enum ...
  - ë³µí•© ìœ í˜•: Closure
```
- KEYPOINT
```markdown
êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ì—ˆëŠ”ë°, ExpressibleByIntegerLeteralì„ ì ìš©í•˜ë‹ˆ = 100ê³¼ ê°™ì€ ë¬¸ë²•ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆë‹¤.
```
